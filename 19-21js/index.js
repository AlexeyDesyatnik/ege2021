/*
kpolyakov.spb.ru № 4035

Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит две кучи
камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может
добавить в любую кучу один камень или увеличить количество камней в любой куче в
три раза. Игра завершается в тот момент, когда общее количество камней в двух
кучах становится не менее 99. В начальный момент в первой куче было 8 камней, а
во второй – S камней, 1 ≤ S ≤ 90.

Ответьте на следующие вопросы: Вопрос 1. Известно, что Ваня выиграл своим первым
ходом после первого хода Пети. Назовите минимальное значение S, при котором это
возможно.

Вопрос 2. Определите, сколько существует таких значений S, при которых у Пети
есть выигрышная стратегия, причём одновременно выполняются два условия: − Петя
не может выиграть за один ход; − Петя может выиграть своим вторым ходом
независимо от того, как будет ходить Ваня.

Вопрос 3. Укажите максимальное значение S, при котором у Вани есть выигрышная
стратегия, позволяющая ему выиграть при любой игре Пети.
*/

// Позиция - список из двух элементов
const getNextPositions = ([a, b]) => [
    [a + 1, b],
    [a * 3, b],
    [a, b + 1],
    [a, b * 3],
];

const isWin = ([a, b]) => (a + b) >= 99;

const MAX_DEPTH = 10;

// Рекурсивный анализ дерева игры. На входе - текущее состояние игры и глубина анализа
// На выходе - положительное число N, если из текущей позиции есть выигрыш за N ходов,
// отрицательное число -N, если из текущей позиции неизбежен проигрыш за макс. N ходов,
// ноль, если исход непонятен (анализ заходит слишком глубоко в дерево ходов)
const analyse = (position, currentDepth) => {
    // Зашли слишком глубоко, прерываем анализ
    if (currentDepth > MAX_DEPTH) return 0;
    // Куда ведут все возможные ходы из текущей позиции
    const nextPositions = getNextPositions(position);
    // Если хотя бы один ход приводит к победе, то позиция - выигрышная за 1 ход
    if (nextPositions.some(isWin)) {
        return 1;
    }
    // Запускаем рекурсивный анализ позиций, полученных нашими ходами
    const analysis = nextPositions.map((nextPos) => analyse(nextPos, currentDepth + 1));
    // Если все результаты анализа положительные, у противника все стратегии выигрышные,
    // значит, у нас нет шансов - выбираем поражение за максимальное кол-во ходов
    if (analysis.every((a) => a > 0)) {
        return Math.max(...analysis) * -1;
    }
    // Отбираем только отрицательные результаты анализа
    const onlyNegative = analysis.filter((a) => a < 0);
    // Если они есть, то...
    if (onlyNegative.length > 0) {
        // ...можно загнать противника в ловушку. Если их несколько, выбираем
        // ближайший к нулю, чтобы быстрее завершить партию. В любом случае добавляется
        // один ход - наш.
        return Math.max(...onlyNegative) * -1 + 1;
    }
    // На тот случай, если ни один результат анализа не дал однозначного ответа
    return 0;
};

console.log('Задача 19')
const a = 8;
for (let b = 1; b <= 90; b += 1) {
    // Подразумевается неудачный ход, поэтому берём следующие позиции и смотрим, кто выигрывает за 1 ход
    const position = [a, b];
    const analysis = getNextPositions(position).map((nextPos) => analyse(nextPos, 0));
    if (analysis.some((a) => a === 1)) {
        console.log(`b = ${b}`);
        break;
    }
}

console.log('Задача 20');
let count = 0;
for (let b = 1; b <= 90; b += 1) {
    const result = analyse([a, b], 0);
    if (result === 2) count += 1;
}
console.log(count);

console.log('Задача 21');
let maxB = 0;
for (let b = 1; b <= 90; b += 1) {
    const result = analyse([a, b], 0);
    if (result < 0) maxB = b;
}
console.log(maxB);