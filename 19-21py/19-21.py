"""
добавить в одну из куч (по своему выбору) один камень или
увеличить количество камней в куче в два раза.
Игра завершается в тот момент, когда суммарное количество камней в кучах становится 
не менее 77. 
Победителем считается игрок, сделавший последний ход, т. е. первым получивший такую
позицию, при которой в кучах будет 77 или больше камней.

В начальный момент в первой куче было семь камней, во второй куче — S камней; 1 ≤ S ≤ 69.

19. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. 
Укажите минимальное значение S, когда такая ситуация возможна

20. Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, 
причём одновременно выполняются два условия:

— Петя не может выиграть за один ход;

— Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.

21. Найдите минимальное значение S, при котором одновременно выполняются два условия:

— у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом
 при любой игре Пети;

— у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
"""

def get_next_positions(position):
    h1, h2 = position
    return [
        [h1 + 1, h2],
        [h1, h2 + 1],
        [h1 * 2, h2],
        [h1, h2 * 2]
    ]


def is_winning(position):
    h1, h2 = position
    return h1 + h2 >= 77

# Предполагается, что position ещё не победная сама по себе
def analyze(position, curr_depth, max_depth):
    # Ограничение глубины анализа
    if curr_depth > max_depth:
        return 0
    next_positions = get_next_positions(position)
    check_winning = [is_winning(p) for p in next_positions]
    # Одна из следующих позиций - победа, до неё 1 ход    
    if any(check_winning):
        return 1
    # Рекурсивный анализ следующих позиций
    next_analysis = [analyze(p, curr_depth + 1, max_depth) for p in next_positions]
    check_positive = [a > 0 for a in next_analysis]
    # Если все следующие позиции победные, мы проигрываем
    # за то же количество ходов
    if all(check_positive):
        return max(next_analysis) * -1
    only_negative = [a for a in next_analysis if a < 0]
    # Если хотя бы одна следующая позиция проигрышная, мы побеждаем
    # за это количество ходов + 1 ход (наш)
    # Если несколько возможных ходов, выбираем ближайший к 0 (самая короткая партия)
    if len(only_negative) > 0:
        return max(only_negative) * -1 + 1
    # В противном случае анализ неоднозначен
    return 0

print("# 19")
for s in range(1, 70):
    a1 = analyze((7 + 1, s), 0, 4)
    a2 = analyze((7, s + 1), 0, 4)
    a3 = analyze((7 * 2, s), 0, 4)
    a4 = analyze((7, s * 2), 0, 4)
    if a1 == 1 or a2 == 1 or a3 == 1 or a4 == 1:
        print(s)
        break

print("# 20")
for s in range(1, 70):
    if analyze((7, s), 0, 4) == 2:
        print(s)

print("# 21")
for s in range(1, 70):
    if analyze((7, s), 0, 4) == -2:
        print(s)
        break